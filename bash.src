import_code("./utils.src")
import_code("./config.src")
import_code("./path.src")
import_code("./prompt.src")
import_code("./builtins.src")
import_code("./cmdProcessor.src")

Bash = function()
	input = user_input(Prompt, false, false, true)
	// if(input.len == 0) then return
	// //output = ""
	// commandChain = input.trim().split(";")
	// if commandChain.len == 0 then return

	commandChain = CommandProcessor.ParseCommandLine(input)
	if commandChain.len == 0 then return

	for cmdDef in commandChain

		command = cmdDef.name
		listCmd = cmdDef.args

		captureScriptsOutput = cmdDef.writePipe or cmdDef.redirectFile != null
		provideInputFromPipe = cmdDef.readPipe

		if captureScriptsOutput then
			get_custom_object["__FANCYBASH_REDIRECT_STDOUT"] = true
		else
			get_custom_object.remove("__FANCYBASH_REDIRECT_STDOUT")
		end if

		if provideInputFromPipe then
			get_custom_object["__FANCYBASH_READ_PREVIOUS_OUTPUT"] = true
		else
			get_custom_object.remove("__FANCYBASH_READ_PREVIOUS_OUTPUT")
			// Clear previous output if not needed
			get_custom_object.remove("__FANCYBASH_PREV_SCRIPT_OUTPUT")
		end if
		
		// Expand environment variables in the command arguments
		Config.ExpandVariables(listCmd)

		// Reconstruct the argument string for passing to commands
		shellArgs = listCmd.join(" ")
		output = command + " " + shellArgs

		// Explicitly handle exit commands
		if ["quit", "exit", "q", "close"].contains(command) then exit

		// Handle built-in commands
		if BuiltIns.hasIndex(command) then
			if captureScriptsOutput then
				// Built-ins support piping/redirection natively, but we need to prepare the output capture
				get_custom_object["__FANCYBASH_SCRIPT_OUTPUT"] = []
			end if
		    BuiltIns[command](shellArgs)
		else
			// Execute external command
		    cmdPath = PathTools.Resolve(command)
		    output = get_shell.launch(cmdPath, shellArgs)
		    if output and output != 1 then print(output)
		end if

		if get_custom_object.hasIndex("__FANCYBASH_SCRIPT_OUTPUT") then
			if cmdDef.redirectFile != null then
				absPath = get_abs_path(cmdDef.redirectFile) // Do not resolve via PATH, just expand from current dir


				fileObj = get_shell.host_computer.File(absPath)
				// print("fileObj on first try: " + fileObj + "("+ typeof(fileObj) +")")
				if not fileObj then
					// print("No file object for path: " + absPath + ". Trying to create the file.")
					dirPath = absPath[:absPath.lastIndexOf("/")]
					// print("dirPath: " + dirPath)
					dirObj = get_shell.host_computer.File(dirPath)
					// print("dirObj: " + dirObj + "("+ typeof(dirObj) +")")
					// if dirObj then
					// 	print("  is_folder: " + dirObj.is_folder)
					// 	print("  has_permission(w): " + dirObj.has_permission("w"))
					// end if

					if dirObj and dirObj.is_folder and dirObj.has_permission("w") then
						// print("touching file at: " + absPath)
						get_shell.host_computer.touch(dirPath, absPath[absPath.lastIndexOf("/")+1:])
						// print("re-checking fileObj...")
						fileObj = get_shell.host_computer.File(absPath)
					end if
				end if

				// print("fileObj: " + fileObj)
				// 	if fileObj then
				// 		print("  is_folder: " + fileObj.is_folder)
				// 		print("  is_binary: " + fileObj.is_binary)
				// 		print("  has_permission(w): " + fileObj.has_permission("w"))
				// 	end if

				if fileObj and not fileObj.is_folder and not fileObj.is_binary and fileObj.has_permission("w") then
					// Write output to the file
					fileObj.set_content(get_custom_object["__FANCYBASH_SCRIPT_OUTPUT"].join(char(10)))
				else
					print("<color=red>[FancyBash] Error: Cannot write to file `" + absPath + "`.")
				end if

				// Clear script output after saving to file
				get_custom_object.remove("__FANCYBASH_SCRIPT_OUTPUT")
				get_custom_object.remove("__FANCYBASH_PREV_SCRIPT_OUTPUT")
			else
				get_custom_object["__FANCYBASH_PREV_SCRIPT_OUTPUT"] = get_custom_object["__FANCYBASH_SCRIPT_OUTPUT"]
				get_custom_object.remove("__FANCYBASH_SCRIPT_OUTPUT")
			end if
		else if captureScriptsOutput then
			// The previous command doesn't implement FancyBash support. Piping or redirection is not possible.
			// Let's show a warning.
			print("<color=yellow>[FancyBash] Warning: Command `" + command + "` does not support piping or redirection.")
		end if
	end for

end function